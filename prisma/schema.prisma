// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// User model
model User {
  id           String   @id @default(cuid())
  email        String   @unique
  passwordHash String
  name         String?
  approved     Boolean  @default(false) // Require admin approval for new signups
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  teamMembers            TeamMember[]
  rsvps                  RSVP[]
  invitations            Invitation[]
  players                Player[]
  leagueUsers            LeagueUser[]
  playerTransfers        PlayerTransfer[]
  sentMessages           LeagueMessage[]
  messageRecipients      MessageRecipient[]
  notificationPreferences NotificationPreference[]
  notificationBatches    NotificationBatch[]
}

// Team model
model Team {
  id        String   @id @default(cuid())
  name      String
  sport     String
  season    String
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Optional league relationship for backward compatibility
  leagueId   String?
  league     League?   @relation(fields: [leagueId], references: [id], onDelete: Restrict)

  divisionId String?
  division   Division? @relation(fields: [divisionId], references: [id])

  members     TeamMember[]
  players     Player[]
  events      Event[]
  invitations       Invitation[]
  homeEvents        Event[] @relation("HomeTeam")
  awayEvents        Event[] @relation("AwayTeam")
  transfersFrom     PlayerTransfer[] @relation("TransferFromTeam")
  transfersTo       PlayerTransfer[] @relation("TransferToTeam")
  messageTargeting  MessageTargeting[]

  @@index([leagueId]) // Optimize league-team queries
  @@index([divisionId]) // Optimize division-team queries
}

// TeamMember junction table with role
model TeamMember {
  id       String   @id @default(cuid())
  role     Role     @default(MEMBER)
  joinedAt DateTime @default(now())

  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  teamId String
  team   Team   @relation(fields: [teamId], references: [id], onDelete: Cascade)

  @@unique([userId, teamId])
}

enum Role {
  ADMIN
  MEMBER
}

// Player model (roster information)
// NOTE: Player represents roster entries for team members who may or may not have user accounts.
// - Players can exist without User accounts (e.g., youth players whose parents manage RSVPs)
// - When a Player accepts an invitation and creates an account, they become linked via TeamMember
// - TeamMember connects authenticated Users to Teams with roles (ADMIN/MEMBER)
// - A single person can exist as both a Player (roster entry) and have a User account (TeamMember)
// - In MVP: Keep Player for roster display, use TeamMember.userId for RSVP and auth operations
model Player {
  id               String   @id @default(cuid())
  name             String
  email            String?
  phone            String?
  emergencyContact String? // Admin-only field, not visible to regular members
  emergencyPhone   String? // Admin-only field, not visible to regular members
  userId           String? // Optional link to User account if player has registered
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  teamId String
  team   Team   @relation(fields: [teamId], references: [id], onDelete: Cascade)
  user   User?  @relation(fields: [userId], references: [id], onDelete: SetNull)

  // Optional league relationship for league-wide roster management
  leagueId String?
  league   League? @relation(fields: [leagueId], references: [id], onDelete: Restrict)

  // Transfer history
  transfers PlayerTransfer[]

  @@index([leagueId]) // Optimize league-wide roster queries
}

// Event model
model Event {
  id        String    @id @default(cuid())
  type      EventType
  title     String
  startAt   DateTime // Combined date and time stored in UTC for proper timezone handling
  location  String
  opponent  String?
  notes     String?
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt

  // Optional league relationship for league-wide scheduling
  leagueId String?
  league   League? @relation(fields: [leagueId], references: [id], onDelete: Restrict)

  teamId String
  team   Team   @relation(fields: [teamId], references: [id], onDelete: Cascade)

  // Multi-team game support
  homeTeamId String?
  homeTeam   Team?   @relation("HomeTeam", fields: [homeTeamId], references: [id])

  awayTeamId String?
  awayTeam   Team?   @relation("AwayTeam", fields: [awayTeamId], references: [id])

  rsvps RSVP[]

  @@index([teamId, startAt]) // Optimize queries for team events sorted by date
  @@index([startAt]) // Optimize queries for upcoming events across teams
  @@index([leagueId, startAt]) // Optimize league event queries
  @@index([homeTeamId, awayTeamId]) // Optimize multi-team game queries
}

enum EventType {
  GAME
  PRACTICE
}

// RSVP model
model RSVP {
  id        String     @id @default(cuid())
  status    RSVPStatus @default(NO_RESPONSE)
  createdAt DateTime   @default(now())
  updatedAt DateTime   @updatedAt

  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  eventId String
  event   Event  @relation(fields: [eventId], references: [id], onDelete: Cascade)

  @@unique([userId, eventId])
}

enum RSVPStatus {
  GOING
  NOT_GOING
  MAYBE
  NO_RESPONSE
}

// Invitation model
model Invitation {
  id        String           @id @default(cuid())
  email     String
  token     String           @unique
  status    InvitationStatus @default(PENDING)
  expiresAt DateTime
  createdAt DateTime         @default(now())
  updatedAt DateTime         @updatedAt

  teamId String
  team   Team   @relation(fields: [teamId], references: [id], onDelete: Cascade)

  invitedById String
  invitedBy   User   @relation(fields: [invitedById], references: [id])
}

enum InvitationStatus {
  PENDING
  ACCEPTED
  EXPIRED
}

// League model - simplified version for MVP
model League {
  id           String   @id @default(cuid())
  name         String
  sport        String
  contactEmail String
  contactPhone String?
  isActive     Boolean  @default(true)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  // Essential relationships only
  divisions              Division[]
  teams                  Team[]
  events                 Event[]
  players                Player[]
  users                  LeagueUser[]
  playerTransfers        PlayerTransfer[]
  messages               LeagueMessage[]
  notificationPreferences NotificationPreference[]
  notificationBatches    NotificationBatch[]

  @@map("leagues")
}

// Basic Division model for team organization
model Division {
  id         String   @id @default(cuid())
  name       String
  ageGroup   String? // U8, U10, Adult, etc.
  skillLevel String? // Recreational, Competitive
  isActive   Boolean  @default(true)
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  leagueId String
  league   League @relation(fields: [leagueId], references: [id], onDelete: Restrict)
  teams    Team[]
  messageTargeting MessageTargeting[]

  @@map("divisions")
}

// Simplified LeagueUser model for role management
model LeagueUser {
  id       String     @id @default(cuid())
  role     LeagueRole
  joinedAt DateTime   @default(now())

  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  leagueId String
  league   League @relation(fields: [leagueId], references: [id], onDelete: Restrict)

  @@unique([userId, leagueId])
  @@map("league_users")
}

enum LeagueRole {
  LEAGUE_ADMIN // Full league control
  TEAM_ADMIN   // Team management within league
  MEMBER       // Basic member
}

// Player transfer history model for audit trail
model PlayerTransfer {
  id              String   @id @default(cuid())
  reason          String?  // Optional reason for transfer
  createdAt       DateTime @default(now())

  playerId        String
  player          Player   @relation(fields: [playerId], references: [id], onDelete: Cascade)

  fromTeamId      String
  fromTeam        Team     @relation("TransferFromTeam", fields: [fromTeamId], references: [id])

  toTeamId        String
  toTeam          Team     @relation("TransferToTeam", fields: [toTeamId], references: [id])

  leagueId        String
  league          League   @relation(fields: [leagueId], references: [id], onDelete: Restrict)

  transferredById String
  transferredBy   User     @relation(fields: [transferredById], references: [id])

  @@map("player_transfers")
}

// League message model for targeted messaging system
model LeagueMessage {
  id          String              @id @default(cuid())
  subject     String
  content     String
  messageType LeagueMessageType   @default(MESSAGE)
  priority    MessagePriority     @default(NORMAL)
  createdAt   DateTime            @default(now())

  leagueId    String
  league      League              @relation(fields: [leagueId], references: [id], onDelete: Cascade)

  senderId    String
  sender      User                @relation(fields: [senderId], references: [id])

  // Message targeting
  targeting      MessageTargeting[]
  recipients     MessageRecipient[]
  batchedMessages BatchedMessage[]

  @@index([leagueId, createdAt])
  @@map("league_messages")
}

enum LeagueMessageType {
  MESSAGE       // Regular targeted message
  ANNOUNCEMENT  // League-wide announcement
}

enum MessagePriority {
  LOW
  NORMAL
  HIGH
  URGENT
}

// Message targeting configuration
model MessageTargeting {
  id        String @id @default(cuid())

  messageId String
  message   LeagueMessage @relation(fields: [messageId], references: [id], onDelete: Cascade)

  // Targeting options (at least one must be specified)
  entireLeague Boolean @default(false)
  divisionId   String?
  division     Division? @relation(fields: [divisionId], references: [id])
  teamId       String?
  team         Team? @relation(fields: [teamId], references: [id])

  @@map("message_targeting")
}

// Message recipients for audit trail
model MessageRecipient {
  id          String   @id @default(cuid())
  sentAt      DateTime @default(now())
  deliveryStatus MessageDeliveryStatus @default(PENDING)

  messageId   String
  message     LeagueMessage @relation(fields: [messageId], references: [id], onDelete: Cascade)

  userId      String
  user        User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([messageId, userId])
  @@map("message_recipients")
}

enum MessageDeliveryStatus {
  PENDING
  SENT
  FAILED
}

// User notification preferences for league communications
model NotificationPreference {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  userId   String
  user     User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  leagueId String?
  league   League? @relation(fields: [leagueId], references: [id], onDelete: Cascade)

  // Notification types
  leagueMessages      Boolean @default(true)  // Targeted league messages
  leagueAnnouncements Boolean @default(true)  // League-wide announcements
  eventNotifications  Boolean @default(true)  // Event created/updated/cancelled
  rsvpReminders       Boolean @default(true)  // RSVP reminder emails
  teamInvitations     Boolean @default(true)  // Team invitation emails

  // Delivery preferences
  emailEnabled        Boolean @default(true)  // Receive emails
  urgentOnly          Boolean @default(false) // Only urgent/high priority messages
  batchDelivery       Boolean @default(false) // Batch non-urgent messages

  // Unsubscribe token for email management
  unsubscribeToken    String? @unique

  @@unique([userId, leagueId])
  @@map("notification_preferences")
}

// Notification batch for grouping non-urgent messages
model NotificationBatch {
  id          String   @id @default(cuid())
  scheduledAt DateTime // When to send the batch
  sentAt      DateTime?
  status      NotificationBatchStatus @default(PENDING)
  createdAt   DateTime @default(now())

  leagueId    String
  league      League @relation(fields: [leagueId], references: [id], onDelete: Cascade)

  userId      String
  user        User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  messages    BatchedMessage[]

  @@index([scheduledAt, status])
  @@map("notification_batches")
}

enum NotificationBatchStatus {
  PENDING
  SENT
  CANCELLED
}

// Individual messages within a notification batch
model BatchedMessage {
  id        String   @id @default(cuid())
  subject   String
  content   String
  priority  MessagePriority
  createdAt DateTime @default(now())

  batchId   String
  batch     NotificationBatch @relation(fields: [batchId], references: [id], onDelete: Cascade)

  // Reference to original message if applicable
  messageId String?
  message   LeagueMessage? @relation(fields: [messageId], references: [id], onDelete: SetNull)

  @@map("batched_messages")
}
